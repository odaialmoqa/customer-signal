import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/lib/types/database';

describe('Security Vulnerability Assessment', () => {
  let supabase: ReturnType<typeof createClient<Database>>;
  let testTenantId: string;
  let testUserId: string;
  let testUserToken: string;

  beforeAll(async () => {
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    // Create test tenant and user for security testing
    const { data: tenant } = await supabase
      .from('tenants')
      .insert({ name: 'Security Test Tenant', subscription: 'professional' })
      .select('id')
      .single();
    testTenantId = tenant!.id;

    const { data: user } = await supabase.auth.admin.createUser({
      email: 'security-vuln-test@example.com',
      password: 'test-password-123',
      email_confirm: true
    });
    testUserId = user.user.id;

    // Get user token for API testing
    const { data: session } = await supabase.auth.admin.generateLink({
      type: 'magiclink',
      email: 'security-vuln-test@example.com'
    });
    testUserToken = session.properties?.access_token || '';

    await supabase
      .from('user_tenants')
      .insert({
        user_id: testUserId,
        tenant_id: testTenantId,
        role: 'user'
      });
  });

  afterAll(async () => {
    await supabase.auth.admin.deleteUser(testUserId);
    await supabase.from('tenants').delete().eq('id', testTenantId);
  });

  describe('SQL Injection Prevention', () => {
    it('should prevent SQL injection in conversation search', async () => {
      const maliciousInput = "'; DROP TABLE conversations; --";
      
      // Test that malicious SQL is properly escaped
      const { error } = await supabase
        .from('conversations')
        .select('*')
        .eq('tenant_id', testTenantId)
        .textSearch('content', maliciousInput);

      // Should not cause an error (SQL injection would cause a syntax error)
      expect(error).toBeNull();
    });

    it('should prevent SQL injection in RPC calls', async () => {
      const maliciousTenantId = "'; DROP TABLE tenants; --";
      
      // Test RPC function with malicious input
      const { error } = await supabase.rpc('export_user_data', {
        p_user_id: testUserId,
        p_tenant_id: maliciousTenantId
      });

      // Should handle invalid UUID format gracefully
      expect(error).toBeDefined();
      expect(error!.message).toContain('invalid input syntax for type uuid');
    });
  });

  describe('Row Level Security (RLS) Enforcement', () => {
    it('should enforce RLS on conversations table', async () => {
      // Create a conversation in another tenant
      const { data: otherTenant } = await supabase
        .from('tenants')
        .insert({ name: 'Other Tenant', subscription: 'basic' })
        .select('id')
        .single();

      await supabase
        .from('conversations')
        .insert({
          tenant_id: otherTenant!.id,
          content: 'Secret conversation',
          author: 'secret-author',
          platform: 'twitter',
          url: 'https://example.com/secret',
          sentiment_score: 0.5,
          sentiment_label: 'neutral'
        });

      // Try to access the conversation from our test user's context
      const userSupabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_ANON_KEY!
      );

      await userSupabase.auth.setSession({
        access_token: testUserToken,
        refresh_token: 'dummy-refresh-token'
      });

      const { data: conversations } = await userSupabase
        .from('conversations')
        .select('*')
        .eq('content', 'Secret conversation');

      // Should not be able to see conversations from other tenants
      expect(conversations).toHaveLength(0);

      // Clean up
      await supabase.from('tenants').delete().eq('id', otherTenant!.id);
    });

    it('should enforce RLS on audit logs', async () => {
      // Create audit log for another tenant
      const { data: otherTenant } = await supabase
        .from('tenants')
        .insert({ name: 'Audit Test Tenant', subscription: 'basic' })
        .select('id')
        .single();

      await supabase
        .from('audit_logs')
        .insert({
          tenant_id: otherTenant!.id,
          table_name: 'conversations',
          record_id: 'test-record-id',
          operation: 'INSERT',
          new_values: { test: 'data' }
        });

      // Try to access audit logs from test user's context
      const userSupabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_ANON_KEY!
      );

      await userSupabase.auth.setSession({
        access_token: testUserToken,
        refresh_token: 'dummy-refresh-token'
      });

      const { data: auditLogs } = await userSupabase
        .from('audit_logs')
        .select('*')
        .eq('tenant_id', otherTenant!.id);

      // Should not be able to see audit logs from other tenants
      expect(auditLogs).toHaveLength(0);

      // Clean up
      await supabase.from('tenants').delete().eq('id', otherTenant!.id);
    });
  });

  describe('Authentication and Authorization', () => {
    it('should require authentication for protected endpoints', async () => {
      const response = await fetch(`${process.env.NEXT_PUBLIC_SUPABASE_URL}/rest/v1/conversations`, {
        headers: {
          'apikey': process.env.SUPABASE_ANON_KEY!,
          'Content-Type': 'application/json'
        }
      });

      // Should require authentication
      expect(response.status).toBe(401);
    });

    it('should validate JWT tokens properly', async () => {
      const invalidToken = 'invalid.jwt.token';
      
      const response = await fetch(`${process.env.NEXT_PUBLIC_SUPABASE_URL}/rest/v1/conversations`, {
        headers: {
          'apikey': process.env.SUPABASE_ANON_KEY!,
          'Authorization': `Bearer ${invalidToken}`,
          'Content-Type': 'application/json'
        }
      });

      // Should reject invalid tokens
      expect(response.status).toBe(401);
    });
  });

  describe('Input Validation and Sanitization', () => {
    it('should validate email formats in user creation', async () => {
      const invalidEmail = 'not-an-email';
      
      const { error } = await supabase.auth.admin.createUser({
        email: invalidEmail,
        password: 'test-password-123'
      });

      // Should reject invalid email formats
      expect(error).toBeDefined();
      expect(error!.message).toContain('email');
    });

    it('should validate UUID formats in database operations', async () => {
      const invalidUuid = 'not-a-uuid';
      
      const { error } = await supabase
        .from('conversations')
        .select('*')
        .eq('tenant_id', invalidUuid);

      // Should reject invalid UUID formats
      expect(error).toBeDefined();
      expect(error!.message).toContain('invalid input syntax for type uuid');
    });

    it('should sanitize HTML content in conversations', async () => {
      const maliciousContent = '<script>alert("XSS")</script>Hello World';
      
      const { data, error } = await supabase
        .from('conversations')
        .insert({
          tenant_id: testTenantId,
          content: maliciousContent,
          author: 'test-author',
          platform: 'twitter',
          url: 'https://example.com/test',
          sentiment_score: 0.5,
          sentiment_label: 'neutral'
        })
        .select('content')
        .single();

      expect(error).toBeNull();
      // Content should be stored as-is (sanitization happens on display)
      expect(data!.content).toBe(maliciousContent);
    });
  });

  describe('Rate Limiting and DoS Protection', () => {
    it('should handle rapid successive requests gracefully', async () => {
      const promises = Array.from({ length: 10 }, () =>
        supabase
          .from('conversations')
          .select('count')
          .eq('tenant_id', testTenantId)
      );

      const results = await Promise.all(promises);
      
      // All requests should complete successfully (Supabase handles rate limiting)
      results.forEach(result => {
        expect(result.error).toBeNull();
      });
    });
  });

  describe('Data Encryption and Storage Security', () => {
    it('should store sensitive data securely', async () => {
      // Test that sensitive fields are properly handled
      const sensitiveData = {
        tenant_id: testTenantId,
        content: 'Sensitive customer feedback with PII',
        author: 'customer@example.com',
        platform: 'email',
        url: 'internal://support-ticket-123',
        sentiment_score: 0.3,
        sentiment_label: 'negative'
      };

      const { data, error } = await supabase
        .from('conversations')
        .insert(sensitiveData)
        .select('*')
        .single();

      expect(error).toBeNull();
      expect(data).toBeDefined();
      
      // Verify data is stored (encryption would be handled at the database level)
      expect(data!.content).toBe(sensitiveData.content);
    });
  });

  describe('Audit Trail Integrity', () => {
    it('should create immutable audit logs', async () => {
      // Create a conversation to trigger audit logging
      const { data: conversation } = await supabase
        .from('conversations')
        .insert({
          tenant_id: testTenantId,
          content: 'Test conversation for audit',
          author: 'audit-test',
          platform: 'twitter',
          url: 'https://example.com/audit',
          sentiment_score: 0.5,
          sentiment_label: 'neutral'
        })
        .select('id')
        .single();

      // Wait for audit trigger to execute
      await new Promise(resolve => setTimeout(resolve, 100));

      // Try to modify the audit log (should fail)
      const { error } = await supabase
        .from('audit_logs')
        .update({ operation: 'MODIFIED' })
        .eq('record_id', conversation!.id);

      // Audit logs should be protected from modification
      // (This depends on database permissions and triggers)
      expect(error).toBeDefined();
    });
  });

  describe('GDPR Compliance Security', () => {
    it('should securely handle data export requests', async () => {
      const { data, error } = await supabase
        .from('gdpr_export_requests')
        .insert({
          tenant_id: testTenantId,
          user_id: testUserId,
          request_type: 'data_export',
          status: 'pending'
        })
        .select('*')
        .single();

      expect(error).toBeNull();
      expect(data!.status).toBe('pending');
      
      // Verify that export URLs are not exposed until processing is complete
      expect(data!.export_url).toBeNull();
    });

    it('should require proper authorization for data deletion', async () => {
      // Test that data deletion requests require proper validation
      const { data, error } = await supabase
        .from('gdpr_export_requests')
        .insert({
          tenant_id: testTenantId,
          user_id: testUserId,
          request_type: 'data_deletion',
          status: 'pending'
        })
        .select('*')
        .single();

      expect(error).toBeNull();
      expect(data!.request_type).toBe('data_deletion');
      expect(data!.status).toBe('pending');
    });
  });

  describe('Session Management Security', () => {
    it('should handle session expiration properly', async () => {
      // Create a client with an expired token
      const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.invalid';
      
      const userSupabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_ANON_KEY!
      );

      await userSupabase.auth.setSession({
        access_token: expiredToken,
        refresh_token: 'dummy-refresh-token'
      });

      const { error } = await userSupabase
        .from('conversations')
        .select('*')
        .limit(1);

      // Should reject expired tokens
      expect(error).toBeDefined();
    });
  });
});